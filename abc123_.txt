title: log nginx request to rabbitmq --advance
date: 2014-10-14 17:29:32
tags: hbase
description: "Hbase MVCC 介绍"
toc: true
category: hbase
comment: true
---
## Hbase MVCC 介绍
__________

##读写一致性
首先假定Hbase如果没有做一致性, 首先思考一个场景, 假如现在数据库中已经有这么一条数据
| row        | age   | country  |
| --------   | -----:  | ----:  |
| 00001     | 15 |   CN     |
假定当前有一个写请求, 想要把数据修改成
| 00001      | 16      | US     | 
| --------   | -----:  | ----:  |

这个时候有个读请求, 尝试读取该数据, 此时Write请求刚执行一半, 数据库中的数据是这样的
| 00001      | 16      | CN     | 
| --------   | -----:  | ----:  |

这就存在读取数据不一致的问题。

那么我们来看看Hbase是怎么解决一致性问题的。

写请求流程:

    > 每一个写请求都分配一个write_number.
    > 当写请求完成后, 更新修改数据的最新number.
    > 更新read point = write_number.(用于读取)
读请求流程
    
    > 读请求时, 给读请求分配一个read_point, 该read_point=Max(write_number)， 该write number为已经完成写请求的write number的集合.
    > 将最大commit的write number的数据读取出来, 作为读取的结果.

那么上面的那个例子中, 如果write请求刚执行一半, 此时读请求读取的还是之前的数据:
| 00001      | 15      | CN     | 
| --------   | -----:  | ----:  |

这种算法, 会存在一条数据是有多个版本(write_number), 所以该方法称之为MVCC(Multiversion Concurrency Control).

##写写
上文中提到, read_point实际上是根据write_number更新的, 那么考虑另外一个场景:
> read_point = write_number=10, 然后按照时间顺序发生以下事件:
> 1. write请求A --- 分配write_number 10. 
> 2. write请求B --- 分配write_number 11.
> 3. write请求B 完成
> 4. read 请求C --- 获取read_point
> 5. write请求A --- 完成.

这种场景下, step 4中, 读请求C读取的read_point, 应该是多少呢？
    
    假如B请求完成了, 就执行read_point=write_number, 那么在A请求没有完成的前提下, C请求仍然存在不一致的状况.

所以C中获取的read_point应该是10, 那么问题又来了, 如果B完成之后不能修改read_point, 以后怎么修改read_point？

因此Hbase里面真是的场景顺序如下:
> read_point = write_number=10, 然后按照时间顺序发生以下事件:
> 1. write请求A --- 分配write_number 10. 
> 2. write请求B --- 分配write_number 11.
> 3. write请求B --- A没有完成, 等待A完成.
> 4. read 请求C --- 获取read_point=10, 读取结果.
> 5. write请求A --- 完成, 直接更新read_point=12, 唤醒等待进程, 结束.
> 6. write请求B --- 被唤醒, 结束.

##结合代码分析
Hbase版本0.96.2
```java
  private final Object readWaiters = new Object();
  // This is the pending queue of writes.
  private final LinkedList<WriteEntry> writeQueue =
      new LinkedList<WriteEntry>();
  //在写请求之前, 获取WriteEntry, 该WriteEntry有当前写请求的writeNumber.
  public WriteEntry beginMemstoreInsert() {
    synchronized (writeQueue) {
      long nextWriteNumber = ++memstoreWrite;
      WriteEntry e = new WriteEntry(nextWriteNumber);
      writeQueue.add(e);
      return e;
    }
  }
  
  boolean advanceMemstore(WriteEntry e) {
    //取出已经完成写请求, 并且更新memstoreRead, 不一定会更新memstoreRead>=e.getWriteNumber.
    synchronized (writeQueue) {
      e.markCompleted();

      long nextReadValue = -1;
      boolean ranOnce=false;
      while (!writeQueue.isEmpty()) {
        ranOnce=true;
        WriteEntry queueFirst = writeQueue.getFirst();

        if (nextReadValue > 0) {
          if (nextReadValue+1 != queueFirst.getWriteNumber()) {
            throw new RuntimeException("invariant in completeMemstoreInsert violated, prev: "
                + nextReadValue + " next: " + queueFirst.getWriteNumber());
          }
        }

        if (queueFirst.isCompleted()) {
          nextReadValue = queueFirst.getWriteNumber();
          writeQueue.removeFirst();
        } else {
          break;
        }
      }

      if (!ranOnce) {
        throw new RuntimeException("never was a first");
      }

      if (nextReadValue > 0) {
        synchronized (readWaiters) {
          memstoreRead = nextReadValue;
          //唤醒等待更新memstoreRea的写请求.
          readWaiters.notifyAll();
        }
      }
      if (memstoreRead >= e.getWriteNumber()) {
        return true;
      }
      return false;
    }
  }
  
  public void waitForRead(WriteEntry e) {
    boolean interrupted = false;
    synchronized (readWaiters) {
      //等待其他的写请求更新memstoreRead
      while (memstoreRead < e.getWriteNumber()) {
        try {
          readWaiters.wait(0);
        } catch (InterruptedException ie) {
          // We were interrupted... finish the loop -- i.e. cleanup --and then
          // on our way out, reset the interrupt flag.
          interrupted = true;
        }
      }
    }
    if (interrupted) Thread.currentThread().interrupt();
  }
```

----
##总结
本文主要介绍了Hbase对数据一致性的实现方式, 并最后结合MVCC的源码给出了简要的说明.
