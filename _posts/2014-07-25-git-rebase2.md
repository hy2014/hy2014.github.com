---
layout: post
title: "git rebase(2)"
description: ""
category: 
tags: [git]
---
{% include JB/setup %}

在前一篇文章中， 介绍了一个git reabse的一个场景， 今天再来介绍一个。

	一般，我们的系统上线之后，production的代码版本是在master上的， 我们还有一个develop的branch，表示正在开发branch。 这个时候如果production上有一个hotfix， 那么我们将要做下面的几个事情。

	1. 在master branch上hot fix。
	2. 将master上的这个hot fix rebase到develop上。

下面介绍一下怎么使用rebase进行实现第二个功能(貌似patch也可以实现， 但是没成功过)

假定develop的最新commit是`a413a16`, 你已经在master上提交了hot fix， 首先看一下这个commit

	git log --oneline -3

找到这个commit， 比如是d413a16， 然后rebase到develop的branch
	
	git rebase develop d413a16 -i

`-i`这个参数表示交互， 你会发现你进入了一个文件， 上面显示了这次会rebase的所有commit(git 默认是会把两个branch上次merge之后的commit作为起点， 终点是d413a16这个commit)。

但是我们不需要将所有的commit rebase到develop， 只rebase `d413a16`， 那么就将别的commit注释掉， 然后`:wq`, 退出。 git就开始进行rebase(这一步可能会发生冲突, 解决办法见上一篇rebase文章)。

rebase完成之后， 你会发现你到了一个游离态的branch， 到底发生了什么？

	其实，rebase并没有将当前`d413a16` rebase到develop这个branch， 而是rebase到了这个游离的branch， 这个游离的branch的commit是 develop + `d413a16`。

接下来很简单了，我们只需要将develop的HEAD指向这个游离态就可以了， 我们先切换到develop这个branch。
	
	git checkout develop

然后查看HEAD的log
	
	git reflog --oneline -10

找到游离态的HEAD, 然后改变当前branch的HEAD。
	
	git reset HEAD{X} ---- X是游离态的HEAD标识， 是一个整数

这个时候，你查看一下， 发现develop的代码没有变化， 这又是发生了什么事情？

	使用`git status`查看一下， 你会发现，你的代码有一些modified。 其实`d413a16`这个commit已经应用到了这个develop branch，但是develop的代码内容是在`a413a16`这个commit。 而modified就是compare `a413a16` 和 `d413a16`。

所以最后一个命令就是回滚

	git checkout .

到此为止， 完成目标。
