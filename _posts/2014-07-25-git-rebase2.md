---
layout: post
title: "git rebase(2)"
description: ""
category: 
tags: [git]
---
{% include JB/setup %}

在前一篇文章中, 介绍了一个git reabse的一个场景, 今天再来介绍一个。

	一般,我们的系统上线之后,production的代码版本是在master上的, 我们还有一个develop的branch,表示正在开发branch。 这个时候如果production上有一个hotfix,那么我们将要做下面的几个事情。

	a. 在master branch上hot fix。
	b. 将master上的这个hot fix rebase到develop上。

下面介绍一下怎么使用rebase进行实现第二个功能(貌似patch也可以实现, 但是没成功过)

假定develop的最新commit是`a413a16`,并且已经在master上提交了hot fix, 首先看一下hotfix的commit

	git log --oneline -3

找到这个commit, 假定是`d413a16`, 然后使用rebase命令
	
	git rebase develop d413a16 -i

`-i`这个参数表示交互,执行此命令后, 会进入到一个编辑文件的环境,文件内容显示的是这次会rebase的一些commit(git 默认是会把两个branch上次merge之后的commit作为起点, 终点是`d413a16`这个commit)。

但是我们不需要将所有的commit rebase到develop, 只是rebase `d413a16`, 使用'#'将别的commit注释掉, 然后`:wq`, 退出。 git开始进行rebase(这一步可能会发生冲突, 解决冲突就不介绍了)。

rebase完成之后,你会发现你进入到了一个游离态的branch, 到底发生了什么？

	其实,rebase并没有将当前d413a16 rebase到develop这个branch, 而是rebase到了游离的branch, 这个游离的branch的commit是 develop + d413a16。

接下来很简单了,我们只需要将develop的HEAD指向这个游离态就可以了, 我们先切换到develop这个branch。
	
	git checkout develop

然后查看HEAD的log
	
	git reflog --oneline -10

找到游离态的HEAD, 然后改变当前branch的HEAD。
	
	git reset HEAD{X} ---- X是游离态的HEAD标识, 是一个整数

这个时候,你查看一下, 发现develop的代码没有变化, 这又是为什么？

	使用git status查看一下, 你会发现,你的代码有一些modified。 其实d413a16这个commit已经应用到了这个develop branch,但是develop的代码内容是在a413a16这个commit。 而modified就是compare a413a16 和 d413a16。

所以最后一个命令就是回滚

	git checkout .

到此为止, 完成目标。
